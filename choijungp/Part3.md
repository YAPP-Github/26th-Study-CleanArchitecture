# 3부. 설계원칙 SOLID

좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 SOLID    
SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스를 서로 결합하는 방법을 설명한다.     

SOLID 원칙은 
- 변경에 유연하고,
- 이해하기 쉽고,
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

<br>

## 7장. SRP: 단일 책임 원칙
**하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.**

우발적 중복, 병합을 통해 하나의 책임이 일어나지 않고 있음을 확인할 수 있다.    
- Employee 예제: `calculatePay()`, `reportHours()`, `save()` → CFO, COO, CTO
- 메서드를 각기 다른 클래스로 이동하여 필요한 소스 코드만 포함하도록 하여 해결한다.

---

## 8장. OCP: 개방 · 폐쇄 원칙
**소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**    

이를 위해 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어지게 해야 한다.    

---

## 9장. LSP: 리스코프 치환 원칙
**하위 클래스는 언제나 상위 클래스를 대체할 수 있어야 한다.**       

프로그램의 기능을 변경하지 않고, 하위 클래스를 상위 클래스가 쓰이는 곳에 넣어도 제대로 작동해야 한다.        

---

## 10장. ISP: 인터페이스 분리 원칙
**소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.**        

필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 불필요한 재컴파일과 재배포를 강제하기 때문에 해로운 일이다.       

---

## 11장. DIP: 의존성 역전 원칙
**고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 의존해서는 안되고, 세부사항이 정책에 의존해야 한다.** (의존성이 추상에 의존하며, 구체에는 의존하지 않는 시스템)          

- 변동성이 큰 구체 클래스를 참조하지 말라
    - 대신 추상 인터페이스를 참조
- 변동성이 큰 구체 클래스로부터 파생하지 말라
    - 상속을 신중하게 사용하라
- 구체 함수를 오버라이드 하지 말라
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
