# 1장. 설계와 아키텍쳐란?

저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소, 경계가 뚜렷하지 않음

SA의 목표는 시스템을 만들고 인력 리소스를 최소화 하는 것

프로그램이 커질수록 점점 증가하는 리소스를 줄이기 위해서는 효율적인 아키텍처가 필수

# 2장. 두 가지 가치에 대한 이야기

개발자는 행위와 아키텍쳐, 두가지 가치를 제공

-   행위:
    기능명세서나 요구사항을 만족하도록 작성하는 것
-   아키텍처:
    변경하기 쉬워야 함
    드는 어려움은 변경의 범위에 비례해야 하며, 형태와는 관련이 없어야 함

# 3장. 패러다임 개요

### 구조적 프로그래밍

-   최초로 적용된 패러다임
-   무분별한 goto의 해로움 제시
-   if/then/else 와 같은 구조로 대체
-   제어흐름의 직접적인 전환에 대해 규칙을 부과

### 객체지향 프로그래밍

-   함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역변수가 오래 유지될 수 있음을 발견
    → 클래스의 생성자가 됨
    지역 변수 → 인스턴스 변수, 중첩 함수 → 메소드
-   제어흐름의 간접적인 전환에 대해 규칙을 부과함

### 함수형 프로그래밍

-   람다계산법의 기초개념은 불변성.
-   심볼의 값이 변경되지 않음
-   할당문이 없음
-   할당문에 대해 규칙을 부과하는 패러다임

# 4장. 구조적 프로그래밍

### 유클리드 계층 구조

유클리드 계층 구조:

가장 아래에 있는 공리(Axiom)로부터 출발해서, 정의(Definition) → 정리(Theorem) → 증명(Proof)으로 위로 올라가는 논리적이고 계층적인 구조

### 증명

다익스트라는 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있음을 발견if/then/else 와 같은 분기, 반복이 goto보다 좋은 방식임을 제시

프로그램이 순차, 분기, 반복만으로 표현될 수 있음이 증명됨

### 기능적 분해

구조적 프러그래밍을 통해 모듈을 증명 가능한 더 작은 단위인 기능으로 분해할 수 있게 됨

거대한 요구사항 → 고수준 분해 → 저수준 분해

### 테스트

테스트는 버그가 없을을 보장하지 못함. 버그가 있음만을 증멱 가능

충분한 테스트가 있을 경우 프로그램이 목표에 부합할 만큼의 참이라고 여길 수 있음

### 결론

아키텍처관점에서는 기능적 분해를 최고의 실천법으로 생각함

작은 기능에서 큰 컴포넌트까지 모든 수준에서의 소프트웨어는 반증 가능성(테스트)에 의해 주도됨

이를 위해 구조적 프로그래밍과 유사한 제한들을 받아들여야 함

# 5장. 객체지향 프로그래밍

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발

OO는 보통 다음과 같이 설명됨

-   데이터와 함수의 조합(모호)
-   실제 세계를 모델링하는 방법(모호)
-   캡슐화, 상속, 다형성

### 캡슐화?

OO는 데이터와 함수를 효과적으로 캡슐화 하는 방법을 제공

데이터는 은닉되고, 일부 함수만이 노출됨

하지만 OO가 아닌 언어에서도 캡슐화는 가능

많은 OO언어가 캡슐화를 강제하지도 않음

### 상속?

OO는 상속에 대해서는 유의미

하지만 어떤 변수화 함수를 하나의 유효범위로 묶어서 재정의하는 일에 불과

OO언어 전에도 C에서도 비슷하게 가능

### **다형성?**

OO 이전에도 함수 포인터로 사용 가능했음

하지만, 함수 포인터에 대한 직접적인 사용을 없애주고 실수할 위험을 줄임으로써, 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 해줌

OO 언어에서 다형성은 쉽게 사용 가능하므로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과

### **다형성이 가진 힘**

OO의 등장으로 다형성을 손쉽게 사용할 수 있게 되면서 언제 어디서든 플러그인 아키텍처를 적용

플러그인 아키텍처:
인터페이스나 추상화된 객체에 의존해 손쉽게 구현체를 바꿀 수 있는 아키텍처

### **의존성 역전**

다형성 적용 전:

소스코드의 의존성은 제어흐름을 따름

main → 고수준 함수 → 저수준 함수

다형성 메커니즘 등장 후:

인터페이스를 통해 의존성 역전 가능

배포 독립성과 개발 독립성 생김

# **6장. 함수형 프로그래밍**

### 불변성과 아키텍처

경합 조건, 교착 상태, 동시 갱신 문제는 모두 가변 변수로 인해 생기는 문제

어떠한 변수도 변하지 않는다면 위 문제가 일어나지 않음

불변성은 리소스, 속도가 무한하다면 실현 가능.

하지만 자원이 무한대가 아니라면 일종의 타협이 필요

### **가변성의 분리**

애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야함

가능한 많은 처리를 불변 컴포넌트로 옮기고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내자

### **이벤트 소싱**

상태가 아닌 트랜잭션을 저장하자는 전략이며, 트랜잭션을 저장하면 가변 변수가 하나도 필요없음

완전한 함수형 가능

상태관리 프로그램과 비슷
