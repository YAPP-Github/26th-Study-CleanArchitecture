# 3장 패러다임 개요
- 구조적 프로그래밍: 무분별한 점프(goto문)은 프로그램 구조에 해롭다
- 객체 지향 프로그래밍: 제어흐름의 간접적인 전환에 대해 규칙을 부과한다
- 함수형 프로그래밍: 할당문에 대해 규칙을 부과한다

→ 패러다임은 '무엇을 해서는 안 되는지'를 말해준다. 3개의 패러다임과 아키텍처의 3개의 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.

# 4장 구조적 프로그래밍
- 모든 프로그램을 sequence(순차), selection(분기), iteration(반복)의 3가지 구조만으로 표현할 수 있음
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 됨
- 즉, 모듈을 기능적으로 분해할 수 있다
- 기능적 분해를 통해 프로그래밍에서 반증(테스트) 가능한 단위를 만들어낼 수 있음

# 5장 객체 지향 프로그래밍
- 캡슐화, 상속, 다형성
### 캡슐화
- 객체 지향 언어가 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공 -> 헤더&구현체 분리하면서 캡슐화 훼손됨
### 상속
- 다중 상속, 업캐스팅을 더 쉽게 할 수 있게 제공
### 다형성
- 포인터를 통한 다형성 제공은 객체지향 이전에도 존재. OOP는 더 안전하고 편리하게 사용할 수 있도록 제공(함수 포인터의 위험성 제거)
### 의존성 역전
- 제어흐름은 시스템의 행위에 따라 결정됨. 소스 코드 의존성은 제어흐름에 따라 결정됨. 하지만 다형성에 의해 상속 관계가 제어 흐름과 반대로 갈 수 있음. 인터페이스를 추가함으로써 의존성 역전 관계를 구축할 수 있음. 원하는대로 의존성을 원하는 방향대로 설정할 수 있음

<img width="800" alt="스크린샷 2025-06-14 오후 9 52 53" src="https://github.com/user-attachments/assets/c8e7e09b-0e69-4813-beca-57e71b3f3ba4" />

- Business Rule(아마 도메인 영역?)을 UI와 Database와 독립적으로 배포할 수 있음.

→ 배포 독립성 & 개발 독립성(서로 다른 팀에서 모듈을 독립적으로 개발할 수 있음)

### 결론
**의존성 역전 원칙(Dependency Inversion Principle, DIP)** 을 적용해 시스템 전체의 소스 코드 의존 관계를 직접 제어할 수 있게 만드는 것
1. 상위 모듈(High-Level Policy)과 하위 모듈(Low-Level Details)을 분리
	- 비즈니스 규칙이나 핵심 로직을 담은 상위 모듈은 “어떤 일을 해야 할지”만 정의하는 인터페이스(프로토콜)를 가짐
	- 실제 구현(데이터베이스 액세스, 네트워크 호출, UI 렌더링 등)은 이 인터페이스를 구현한 하위 모듈이 담당
2. 플러그인 형태의 모듈 구조
	- 상위 모듈은 인터페이스만 참조하므로, 구체적인 구현체(플러그인)는 런타임에 자유롭게 교체·추가할 수 있음
	- 예를 들어, `PaymentProcessor` 프로토콜만 정의해 두면, `CreditCardProcessor`, `PayPalProcessor` 같은 여러 구현체를 플러그인처럼 붙였다 뗄 수 있음
3. 모듈 독립성 보장
	- 인터페이스를 사이에 두고 서로 의존하기 때문에, 하위 모듈(세부 구현)이 바뀌어도 상위 모듈은 전혀 신경 쓸 필요가 없음
	- 반대로 상위 모듈을 확장할 때도 하위 모듈을 건드리지 않고, 새 플러그인만 추가하면 됨
즉, 핵심 로직(상위 모듈)은 **정책(Policy)** 에만 집중하고 구체적인 기능(하위 모듈)은 **플러그인(Plugin)** 으로 관리하여 모듈 간 결합도 낮출 수 있음

# 6장 함수형 프로그래밍
- 변수는 변경되지 않음 -> 가변변수가 없으면 많은 문제가 발생하지 않음.
- 하지만 모든 걸 불변 변수로 사용할 수 없음(리소스가 제한되어있기 때문에)

### 이벤트 소싱(Event Sourcing)
- 상태(State)가 아닌, 상태를 바꾼 트랜잭션(이벤트) 만 저장하는 전략
- 필요할 때마다 처음부터 모든 이벤트를 재연산(Replay) → 현재 상태를 복원
- 이 전략에 맞는 데이터 저장소: 이벤트 스토어에 기록된 데이터는 영원히 보관(삭제, 변경 불가) → C, R만 하므로 race condition 문제 발생하지 않음

## 종합 결론

| 패러다임       | 부과되는 규율                         |
| ---------- | ------------------------------- |
| 구조적 프로그래밍  | 제어 흐름(흐름 제어문)을 직접 조작하는 규율       |
| 객체지향 프로그래밍 | 제어 흐름을 간접(메시지·메서드 호출)으로 전환하는 규율 |
| 함수형 프로그래밍  | 변수 할당(상태 변경) 자체에 대한 규율          |
- **Sequence** (순차)  
    코드는 한 줄씩 차례대로 실행된다.
- **Selection** (분기)  
    `if`/`switch` 같은 조건 분기.
- **Iteration** (반복)  
    `for`/`while` 같은 반복 구조.
- **Indirection** (참조)  
    함수 호출, 메시지 전달, 포인터/레퍼런스 등을 통한 간접 접근.
