[Velog로 보기](https://velog.io/@doyeonk429/클린-아키텍처)

# 설계 원칙

- 좋은 벽돌 (잘 작성된 클래스와 메서드)을 준비하고, 이 벽돌을 쌓는 방법을 **SOLID 원칙**을 통해 올바르게 설계해야 견고하고 유지보수하기 좋은 소프트웨어(건물)가 완성된다.

## SOLID 원칙의 목적

**중간 수준의 소프트웨어 구조**가 **변경에 유연**하고, **이해하기 쉽고**, 많은 소프트웨어 **시스템에 사용될 수 있는 컴포넌트의 기반**이 되도록 만드는 것이 목적이다.

- 중간 수준? 모듈 수준에서 작업할 때 적용. 코드(Low) < 모듈(Mid) < 아키텍처/시스템(High)
1. SRP: 각 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다.
2. OCP: 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다
3. LSP: 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 구성요소는 반드시 서로 치환 가능해야 한다
4. ISP: 설계는 사용하지 않는 것에 의존하지 않아야 한다
5. DIP: 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.
- SOLID 원칙이 아키텍처 관점에서 지닌 의미에 집중해 논의하고자 함(이 책에서)

## SRP: 단일 책임 원칙

하나의 모듈은 하나의 액터에 대해서만 책임져야 한다.

- 단일 액터를 책임지는 코드를 함께 묶어주는 힘 = 응집성cohesion

### 위반하는 징후

1. 우발적 중복: 서로 다른 액터가 의존하는 코드를 너무 가까이 배치하면 발생하는 문제.
2. 병합

### 해결책

- 데이터와 메서드를 분리하는 방식
- 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함시킨다 → 우연한 중복 회피 가능
- Facade 패턴을 통해 해결 가능

### 결론

- SRP는 메서드와 클래스 수준의 원칙 → 이후 CCP와 연관됨

## OCP: 개방-폐쇄 원칙

> 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다
> 
- 방향성 제어, 정보 은닉
- 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화

시스템을 컴포넌트 단위로 분리, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다

## LSP: 리스코프 치환 원칙

### 상속을 사용하도록 가이드하기

- 라이센스 → 개인 라이센스/비즈니스 라이센스가 ‘라이센스’ 클래스를 상속받아, 연관된 Billing이라는 행위가 라이센스의 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않는 구조가 가능해짐

### 정사각형/직사각형 문제

- 직사각형은 높이, 너비를 각각 설정할 수 있으나 정사각형은 높이와 너비가 항상 같이 설정되어야만 한다 → 직사각형 클래스를 정사각형 클래스가 상속받으면 문제가 생긴다. → 타입 치환 불가

### LSP 위배 사례

특별 케이스가 추가됨에 따라 하드코딩과 분기로 직접 예외 처리하는 사례

### 결론

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.

## ISP: 인터페이스 분리 원칙

- User1에서는 op2와 op3를 전혀 사용하지 않음에도 User1 의 소스 코드는 이 두 메서드에 의존하게 됨 → 그림 2처럼 분리하면 OPS에서 발생한 변경이 User1과 관련이 없다면 User1을 다시 컴파일, 배포하지 않아도 됨

## DIP: 의존성 역전 원칙

유연성이 극대화된 시스템: 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템

→ 전부는 실질적으로 불가능. 주요한 것은 변동성이 큰 구체적 요소에 의존하지 말자!

- 인터페이스는 구현체보다 변동성이 낮음.

곡선은 아키텍처 경계. 의존성은 곡선을 경계로 더 추상적인 엔티티가 있는 쪽으로만 향함.
